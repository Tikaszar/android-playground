# Engine Design Clarification

This document outlines the finalized architectural design for the engine, focusing on the separation of the ECS implementation from the public API, and the strict layering that follows.

## Core Principles

1.  **Stateless Core:** The `core/*` layer is entirely stateless, providing only abstract traits and contracts. `core/ecs` defines the *contract* for an ECS, not its implementation.

2.  **Stateful Systems:** The `systems/*` layer contains the stateful implementations of the `core` contracts.

3.  **System Isolation:** Engine Systems (e.g., `systems/ui`, `systems/webgl`) are isolated and cannot depend on each other.

4.  **Unified ECS in `systems/ecs`:** The new `systems/ecs` crate contains the single, stateful, unified ECS `World` implementation for the entire engine. It is the only system that implements the `core/ecs` contract.

5.  **`systems/logic` as the Sole API:** Plugins and Apps may **only** interact with `systems/logic`. It is a stateless API gateway that provides all public-facing functions and types, completely hiding all other `core` and `systems` packages. **systems/logic ONLY uses core/* contracts and NEVER imports other systems.**

6.  **Plugins as ECS Systems:** Plugins are high-level, feature-specific systems that are run by the `systems/ecs` scheduler.

7.  **Static Registry Pattern:** A compile-time build script discovers and loads all systems. Systems self-register with a static registry provided by `core/ecs` contracts. This build script is the ONLY place that knows about concrete system types, maintaining clean separation everywhere else.

---

## End-to-End Flow

This describes the full flow, from application startup to a single rendered frame, using `playground-editor` as the example application.

### 1. Initialization & Registration (The Setup Phase)

1.  **Build Script Loads Systems:** At compile time, a build script discovers all available systems. At runtime, this script loads the concrete system implementations, which self-register with the static registry provided by `core/ecs` contracts.

2.  **App Starts as a Generic Runner:** The `playground-editor` binary launches. Its only dependency is `playground-systems-logic`.

3.  **systems/logic Orchestrates:** The App calls an API function in `systems/logic` to initialize the engine. `systems/logic` queries the static registry (via `core/ecs` contracts) to discover what systems have been loaded. It orchestrates their initialization without knowing their concrete types.

4.  **Infrastructure Initialization:** `systems/logic` uses `core/server` (which is in core/*, so it's allowed) to start the WebSocket server, Dashboard, and other infrastructure components.

5.  **Plugins are Registered by the App:** The `playground-editor` App then makes explicit calls to the `systems/logic` API to load and register the specific plugins it requires for its functionality, such as `plugins/file-browser`.

### 2. The Execution Flow (A Single Frame Tick)

The App's main loop simply calls `logic.update(delta_time)` each frame. This call is forwarded by `systems/logic` to the `systems/ecs` scheduler, which executes all registered systems (both Engine Systems and Plugins) in their designated stages, creating a clear data pipeline.

1.  **`Update` Stage Begins:** The `systems/ecs` scheduler starts executing all systems registered in the `Update` stage.
    *   The `FileBrowserPlugin`'s `run` method is called.
    *   The plugin's logic executes. It interacts with the engine **only through the `systems/logic` API**. It creates entities and adds data to them using public types like `logic::UiElementComponent`.

2.  **`Layout` Stage Begins:** The scheduler moves to the next stage.
    *   The `UiSystem`'s `run` method is called.
    *   `systems/logic` translates the public `logic::UiElementComponent` data into internal component data that `UiSystem` can query from the `systems/ecs::World`.
    *   The `UiSystem` performs layout calculations and generates a batch of generic `RenderCommand`s.

3.  **`Render` Stage Begins:** The scheduler moves to the final relevant stage.
    *   The `WebGLRenderer` system's `run` method is called.
    *   It finds the `RenderCommand`s generated by the `UiSystem`.
    *   It processes these commands, converting them into WebGL-specific data and sending them to the browser to be displayed on the screen.

---

## Static Registry Architecture

The static registry pattern is the key to maintaining clean separation while allowing systems to be discovered and orchestrated:

### How It Works

1. **core/ecs Provides the Contract:**
   - Defines a static registry interface/trait
   - Provides registration and query methods
   - No implementation, just the contract

2. **systems/ecs Implements the Registry:**
   - Provides the actual static registry implementation
   - Stores references to loaded systems
   - Manages the unified World

3. **Build Script (The Only Violation):**
   ```rust
   // Generated by build system - this is the ONLY place that knows concrete types
   fn load_systems() {
       systems::ecs::register();
       systems::networking::register();
       systems::ui::register();
       systems::webgl::register();
       // ... other systems
   }
   ```

4. **System Self-Registration:**
   ```rust
   // In each system's register() function
   pub fn register() {
       STATIC_REGISTRY.register_system("networking", || {
           Box::new(NetworkingSystem::new())
       });
   }
   ```

5. **systems/logic Queries the Registry:**
   ```rust
   // systems/logic uses core/ecs contracts only
   use core::ecs::SystemRegistry;
   
   pub fn initialize_engine() {
       let systems = SystemRegistry::get_all_systems();
       // Orchestrate without knowing concrete types
   }
   ```

### Benefits

- **Clean Separation:** Only the build script knows about concrete system types
- **No Cross-Dependencies:** Systems don't import each other
- **API Gateway Preserved:** systems/logic remains stateless and only uses core/*
- **Compile-Time Discovery:** Systems are discovered at build time, not runtime
- **Single Violation Point:** The build script is the controlled violation, outside the runtime architecture
