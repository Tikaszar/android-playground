# Engine Design Clarification

This document outlines the finalized architectural design for the engine, focusing on the separation of the ECS implementation from the public API, and the strict layering that follows.

## Core Principles

1.  **Stateless Core:** The `core/*` layer is entirely stateless, providing only abstract traits and contracts. `core/ecs` defines the *contract* for an ECS, not its implementation.

2.  **Stateful Systems:** The `systems/*` layer contains the stateful implementations of the `core` contracts.

3.  **System Isolation:** Engine Systems (e.g., `systems/ui`, `systems/webgl`) are isolated and cannot depend on each other.

4.  **Unified ECS in `systems/ecs`:** The new `systems/ecs` crate contains the single, stateful, unified ECS `World` implementation for the entire engine. It is the only system that implements the `core/ecs` contract.

5.  **`systems/logic` as the Sole API:** Plugins and Apps may **only** interact with `systems/logic`. It is a stateless API gateway that provides all public-facing functions and types, completely hiding all other `core` and `systems` packages.

6.  **Plugins as ECS Systems:** Plugins are high-level, feature-specific systems that are run by the `systems/ecs` scheduler.

7.  **Two-Stage, Code-Driven Setup:** A compile-time process discovers available Engine Systems. The App then programmatically loads the specific Plugins it needs. This is orchestrated by `systems/logic`.

---

## End-to-End Flow

This describes the full flow, from application startup to a single rendered frame, using `playground-editor` as the example application.

### 1. Initialization & Registration (The Setup Phase)

1.  **App Starts as a Generic Runner:** The `playground-editor` binary launches. Its only dependency is `playground-systems-logic`.

2.  **Unified ECS is Created:** The App calls an API function in `systems/logic` to initialize the engine. Internally, this instantiates the single, unified `systems/ecs::World`. The App receives only an opaque handle.

3.  **Engine Systems are Registered:** `systems/logic` uses a compile-time generated manifest to discover and register all available Engine Systems (like `systems/webgl` and `systems/ui`) with the `systems/ecs::World`.

4.  **Plugins are Registered by the App:** The `playground-editor` App then makes explicit calls to the `systems/logic` API to load and register the specific plugins it requires for its functionality, such as `plugins/file-browser`.

### 2. The Execution Flow (A Single Frame Tick)

The App's main loop simply calls `logic.update(delta_time)` each frame. This call is forwarded by `systems/logic` to the `systems/ecs` scheduler, which executes all registered systems (both Engine Systems and Plugins) in their designated stages, creating a clear data pipeline.

1.  **`Update` Stage Begins:** The `systems/ecs` scheduler starts executing all systems registered in the `Update` stage.
    *   The `FileBrowserPlugin`'s `run` method is called.
    *   The plugin's logic executes. It interacts with the engine **only through the `systems/logic` API**. It creates entities and adds data to them using public types like `logic::UiElementComponent`.

2.  **`Layout` Stage Begins:** The scheduler moves to the next stage.
    *   The `UiSystem`'s `run` method is called.
    *   `systems/logic` translates the public `logic::UiElementComponent` data into internal component data that `UiSystem` can query from the `systems/ecs::World`.
    *   The `UiSystem` performs layout calculations and generates a batch of generic `RenderCommand`s.

3.  **`Render` Stage Begins:** The scheduler moves to the final relevant stage.
    *   The `WebGLRenderer` system's `run` method is called.
    *   It finds the `RenderCommand`s generated by the `UiSystem`.
    *   It processes these commands, converting them into WebGL-specific data and sending them to the browser to be displayed on the screen.
