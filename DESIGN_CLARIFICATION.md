# Engine Design Clarification

This document outlines the finalized architectural design for the engine, focusing on the separation of the ECS implementation from the public API, and the strict layering that follows.

## Core Principles

1.  **Stateless Core:** The `core/*` layer is entirely stateless, providing only abstract traits and contracts. `core/ecs` defines the *contract* for an ECS, not its implementation.

2.  **Stateful Systems:** The `systems/*` layer contains the stateful implementations of the `core` contracts.

3.  **System Isolation:** Engine Systems (e.g., `systems/ui`, `systems/webgl`) are isolated and cannot depend on each other.

4.  **Unified ECS in `systems/ecs`:** The new `systems/ecs` crate contains the single, stateful, unified ECS `World` implementation for the entire engine. It is the only system that implements the `core/ecs` contract.

5.  **`systems/logic` as the Sole API:** Plugins and Apps may **only** interact with `systems/logic`. It is a stateless API gateway that provides all public-facing functions and types, completely hiding all other `core` and `systems` packages. **systems/logic ONLY uses core/* contracts and NEVER imports other systems.**

6.  **Systems Expose Functionality Through ECS:** All engine systems (networking, console, ui, webgl) expose their functionality through the ECS World using command processors, not through direct imports. This maintains system isolation while allowing coordinated functionality.

7.  **Plugins as ECS Systems:** Plugins are high-level, feature-specific systems that are run by the `systems/ecs` scheduler.

8.  **Static Registry Pattern:** A compile-time build script discovers and loads all systems. Systems self-register with a static registry provided by `core/ecs` contracts. This build script is the ONLY place that knows about concrete system types, maintaining clean separation everywhere else.

---

## End-to-End Flow

This describes the full flow, from application startup to a single rendered frame, using `playground-editor` as the example application.

### 1. Initialization & Registration (The Setup Phase)

1.  **Build Script Loads Systems:** At compile time, a build script discovers all available systems. At runtime, this script loads the concrete system implementations, which self-register with the static registry provided by `core/ecs` contracts.

2.  **App Starts as a Generic Runner:** The `playground-editor` binary launches. Its only dependency is `playground-systems-logic`.

3.  **systems/logic Orchestrates:** The App calls an API function in `systems/logic` to initialize the engine. `systems/logic` queries the static registry (via `core/ecs` contracts) to discover what systems have been loaded. It orchestrates their initialization without knowing their concrete types.

4.  **Infrastructure Initialization:** `systems/logic` orchestrates system initialization through the ECS. Systems like `systems/networking` and `systems/console` register command processors with the World to expose their functionality. The API gateway in `systems/logic` provides clean functions that internally use these command processors.

5.  **Plugins are Registered by the App:** The `playground-editor` App then makes explicit calls to the `systems/logic` API to load and register the specific plugins it requires for its functionality, such as `plugins/file-browser`.

### 2. The Execution Flow (A Single Frame Tick)

The App's main loop simply calls `logic.update(delta_time)` each frame. This call is forwarded by `systems/logic` to the `systems/ecs` scheduler, which executes all registered systems (both Engine Systems and Plugins) in their designated stages, creating a clear data pipeline.

1.  **`Update` Stage Begins:** The `systems/ecs` scheduler starts executing all systems registered in the `Update` stage.
    *   The `FileBrowserPlugin`'s `run` method is called.
    *   The plugin's logic executes. It interacts with the engine **only through the `systems/logic` API**. It creates entities and adds data to them using public types like `logic::UiElementComponent`.

2.  **`Layout` Stage Begins:** The scheduler moves to the next stage.
    *   The `UiSystem`'s `run` method is called.
    *   `systems/logic` translates the public `logic::UiElementComponent` data into internal component data that `UiSystem` can query from the `systems/ecs::World`.
    *   The `UiSystem` performs layout calculations and generates a batch of generic `RenderCommand`s.

3.  **`Render` Stage Begins:** The scheduler moves to the final relevant stage.
    *   The `WebGLRenderer` system's `run` method is called.
    *   It finds the `RenderCommand`s generated by the `UiSystem`.
    *   It processes these commands, converting them into WebGL-specific data and sending them to the browser to be displayed on the screen.

---

## System Architecture and Command Processors

Each engine system exposes its functionality through the ECS World using command processors, similar to how `systems/ecs` exposes World operations:

### System Separation

1. **core/console:** Defines GENERIC console/logging contracts (could be terminal, file, GUI, network)
2. **systems/console:** Implements contracts for TERMINAL (ANSI, dashboard) - one possible implementation
3. **core/server:** Defines GENERIC server contracts (could be TCP, UDP, IPC, named pipes, etc.)
4. **systems/networking:** Implements contracts for WebSocket/HTTP - one possible implementation
5. **core/client:** Defines GENERIC client contracts (could be browser, native, mobile, CLI)
6. **systems/webgl:** Implements contracts for browser/WebGL - one possible implementation
7. **systems/vulkan (future):** Would implement contracts for native/Vulkan - another possible implementation

The key principle: **core/* is ALWAYS generic**, systems/* provides SPECIFIC implementations

### Command Processor Pattern

Each system follows the same pattern as the World command processor:

1. **Define Commands in core/*:**
   ```rust
   // core/server/src/server_commands.rs
   pub enum ServerCommand {
       StartServer { port: u16 },
       SendPacket { channel: u16, data: Bytes },
       RegisterChannel { name: String },
       // ...
   }
   ```

2. **Implement Handler in systems/*:**
   ```rust
   // systems/networking/src/lib.rs
   impl ServerCommandHandler for NetworkingSystem {
       async fn handle_command(&self, cmd: ServerCommand) -> Result<ServerResponse> {
           // Process commands
       }
   }
   ```

3. **Register with World on initialization:**
   ```rust
   // During system initialization
   world.register_command_processor("networking", self.clone());
   ```

4. **systems/logic Provides Clean API:**
   ```rust
   // systems/logic/src/networking_api.rs
   pub async fn start_server(port: u16) -> Result<()> {
       // Send command through World command processor
       playground_core_server::start_server(port).await
   }
   ```

This pattern ensures:
- Systems remain isolated (no cross-dependencies)
- Functionality is exposed through ECS, not direct imports
- systems/logic provides the only public API
- Plugins/Apps never directly access core/* or systems/*

---

## Static Registry Architecture

The static registry pattern is the key to maintaining clean separation while allowing systems to be discovered and orchestrated:

### How It Works

1. **core/ecs Provides the Contract:**
   - Defines a static registry interface/trait
   - Provides registration and query methods
   - No implementation, just the contract

2. **systems/ecs Implements the Registry:**
   - Provides the actual static registry implementation
   - Stores references to loaded systems
   - Manages the unified World

3. **Build Script (The Only Violation):**
   ```rust
   // Generated by build system - this is the ONLY place that knows concrete types
   fn load_systems() {
       systems::ecs::register();
       systems::networking::register();
       systems::ui::register();
       systems::webgl::register();
       // ... other systems
   }
   ```

4. **System Self-Registration:**
   ```rust
   // In each system's register() function
   pub fn register() {
       STATIC_REGISTRY.register_system("networking", || {
           Box::new(NetworkingSystem::new())
       });
   }
   ```

5. **systems/logic Queries the Registry:**
   ```rust
   // systems/logic uses core/ecs contracts only
   use core::ecs::SystemRegistry;
   
   pub fn initialize_engine() {
       let systems = SystemRegistry::get_all_systems();
       // Orchestrate without knowing concrete types
   }
   ```

### Benefits

- **Clean Separation:** Only the build script knows about concrete system types
- **No Cross-Dependencies:** Systems don't import each other
- **API Gateway Preserved:** systems/logic remains stateless and only uses core/*
- **Compile-Time Discovery:** Systems are discovered at build time, not runtime
- **Single Violation Point:** The build script is the controlled violation, outside the runtime architecture
