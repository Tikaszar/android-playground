use sha2::{Digest, Sha256};
use std::env;
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

pub fn hash_directory(dir: &Path) -> u32 {
    let mut hasher = Sha256::new();

    let mut entries: Vec<_> = WalkDir::new(dir)
        .follow_links(false)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
        .collect();

    entries.sort_by_key(|e| e.path().to_path_buf());

    for entry in entries {
        if let Ok(contents) = fs::read(entry.path()) {
            hasher.update(&contents);
        }
    }

    let result = hasher.finalize();
    u32::from_be_bytes([result[0], result[1], result[2], result[3]])
}

pub fn generate_api_version(manifest_dir: &str) -> u32 {
    let view_dir = Path::new(manifest_dir).join("src/view");
    let model_dir = Path::new(manifest_dir).join("src/model");

    let mut hasher = Sha256::new();

    // Hash view directory if it exists
    if view_dir.exists() {
        let mut entries: Vec<_> = WalkDir::new(&view_dir)
            .follow_links(false)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file())
            .collect();
        entries.sort_by_key(|e| e.path().to_path_buf());

        for entry in entries {
            if let Ok(contents) = fs::read(entry.path()) {
                hasher.update(&contents);
            }
        }
    }

    // Hash model directory if it exists
    if model_dir.exists() {
        let mut entries: Vec<_> = WalkDir::new(&model_dir)
            .follow_links(false)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file())
            .collect();
        entries.sort_by_key(|e| e.path().to_path_buf());

        for entry in entries {
            if let Ok(contents) = fs::read(entry.path()) {
                hasher.update(&contents);
            }
        }
    }

    let result = hasher.finalize();
    u32::from_be_bytes([result[0], result[1], result[2], result[3]])
}

pub fn generate_state_version(manifest_dir: &str) -> u32 {
    let model_dir = Path::new(manifest_dir).join("src/model");
    if model_dir.exists() {
        hash_directory(&model_dir)
    } else {
        0
    }
}

fn check_if_system_module(manifest_dir: &str) -> bool {
    let cargo_toml = Path::new(manifest_dir).join("Cargo.toml");
    if let Ok(contents) = fs::read_to_string(cargo_toml) {
        contents.contains("[package.metadata.playground.implements]")
    } else {
        false
    }
}

fn get_core_path(manifest_dir: &str) -> Option<String> {
    let cargo_toml = Path::new(manifest_dir).join("Cargo.toml");
    let contents = fs::read_to_string(&cargo_toml).ok()?;

    // Parse as a table for better error handling
    let toml_table: toml::map::Map<String, toml::Value> = toml::from_str(&contents).ok()?;

    let package = toml_table.get("package")?.as_table()?;
    let metadata = package.get("metadata")?.as_table()?;
    let playground = metadata.get("playground")?.as_table()?;
    let implements = playground.get("implements")?.as_table()?;
    let core_path = implements.get("core_path")?.as_str()?;

    Some(
        Path::new(manifest_dir)
            .join(core_path)
            .to_string_lossy()
            .to_string()
    )
}

pub fn generate_versions() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")
        .expect("CARGO_MANIFEST_DIR not set");
    let out_dir = env::var("OUT_DIR")
        .expect("OUT_DIR not set");

    let is_system = check_if_system_module(&manifest_dir);

    let versions_file = Path::new(&out_dir).join("versions.rs");

    if is_system {
        let core_path = get_core_path(&manifest_dir)
            .expect("System module must declare core_path in [package.metadata.playground.implements]");

        let core_api_version = generate_api_version(&core_path);
        let state_version = generate_state_version(&core_path);

        let content = format!(
            "// Auto-generated by playground-build-utils\n\
             pub const API_VERSION: u32 = {};\n\
             pub const STATE_FORMAT_VERSION: u32 = {};\n",
            core_api_version,
            state_version
        );
        fs::write(&versions_file, content)
            .expect("Failed to write versions.rs");

        println!("cargo:rerun-if-changed={}/src/view", core_path);
        println!("cargo:rerun-if-changed={}/src/model", core_path);
    } else {
        let api_version = generate_api_version(&manifest_dir);

        let content = format!(
            "// Auto-generated by playground-build-utils\n\
             pub const API_VERSION: u32 = {};\n",
            api_version
        );
        fs::write(&versions_file, content)
            .expect("Failed to write versions.rs");

        println!("cargo:rerun-if-changed=src/view");
        println!("cargo:rerun-if-changed=src/model");
    }
}
